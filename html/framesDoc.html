
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>frames package</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-06-30"><meta name="DC.source" content="framesDoc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>frames package</h1><!--introduction--><p>The frames package contains classes to handle operations on homogeneous data matrices that are referenced by column and index identifiers.</p><p>There are currently no tool in Matlab to do that. Matlab's (time)tables have row and column names, but do not provide simple operations like addition (table1+table2 is not possible). Matlab's native matrices are not aware of row and column names. When data represents observations of variables, it is always tricky to make sure the data is not misaligned.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Frame classes</a></li><li><a href="#3">Constructor</a></li><li><a href="#7">Properties Access and Modification</a></li><li><a href="#11">Sub-Frame Access and Modification</a></li><li><a href="#17">Operations</a></li><li><a href="#24">Concatenation</a></li><li><a href="#26">Particular use of Index</a></li></ul></div><h2 id="1">Frame classes</h2><p>The class <b>frames.DataFrame</b> and its child class <b>frames.TimeFrame</b> aim to give a solution to working with this kind of data (homogeneous and with column and row names), to make operations on and between Frames simple and robust.</p><p>Their main properties are:</p><div><ul><li>data:       TxN,  homogeneous data</li><li>index:      Tx1</li><li>columns:    1xN</li><li>t: dependent table built on the properties above.</li></ul></div><p><i>columns</i> and <i>index</i> are expected to have unique elements. <i>columns</i> allows duplicates but issues a warning if it is the case. <i>index</i> does not accept duplicates. Moreover, for TimeFrame, <i>index</i> is a chronological datetime array.</p><p>The Frames are displayed as a table (DataFrame) and as a timetable (TimeFrame).</p><p>For the documentation, run</p><pre class="codeinput">doc <span class="string">frames.DataFrame</span>
doc <span class="string">frames.TimeFrame</span>
</pre><h2 id="3">Constructor</h2><p>Construct a Frame as follows:</p><pre class="language-matlab">df = frames.DataFrame([data,index,columns,Name=name,RowSeries=logical,ColSeries=logical])
</pre><pre class="codeinput">df = frames.DataFrame([1 2;3 4],[1 2],[<span class="string">"col1"</span>,<span class="string">"col2"</span>])
</pre><pre class="codeoutput">
df = 

         col1    col2
         ____    ____

    1     1       2  
    2     3       4  

</pre><p>or with a TimeFrame</p><pre class="codeinput">tf = frames.TimeFrame([1 2;3 4],[737970,737971],[<span class="string">"ts1"</span>,<span class="string">"ts2"</span>])
</pre><pre class="codeoutput">
tf = 

       Time        ts1    ts2
    ___________    ___    ___

    28-Jun-2020     1      2 
    29-Jun-2020     3      4 

</pre><p>To view the properties of the object, type</p><pre class="codeinput">details(df)
</pre><pre class="codeoutput">
  2&times;2 frames.DataFrame array with properties:

           data: [2&times;2 double]
          index: [2&times;1 double]
        columns: ["col1"    "col2"]
           name: ""
              t: [2&times;2 table]
      rowseries: 0
      colseries: 0
    description: ""


</pre><p>One can see the properties we have just set in the constructor. The other properties (some of which can be set in the constructor with named arguments) are presented further below.</p><h2 id="7">Properties Access and Modification</h2><p>The properties can be accessed simply by</p><pre class="codeinput">df.data
df.columns
</pre><pre class="codeoutput">
ans =

     1     2
     3     4


ans = 

  1&times;2 string array

    "col1"    "col2"

</pre><p>They can also be modified</p><pre class="codeinput">df.data(1,1) = 10;
df.columns = [<span class="string">"a"</span>,<span class="string">"b"</span>]
</pre><pre class="codeoutput">
df = 

         a     b
         __    _

    1    10    2
    2     3    4

</pre><p>Frame will throw an error if the data entered are not coherent, e.g. the size is the matching the rest of the data:</p><pre class="codeinput"><span class="keyword">try</span>
    df.columns = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">columns do not have the same size as data
</pre><p>Or an example with an attempt to assign a duplicate index:</p><pre class="codeinput"><span class="keyword">try</span>
    df.index = [1 1]
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Invalid argument at position 2. Value must be a unique vector or a frames.UniqueIndex.
</pre><h2 id="11">Sub-Frame Access and Modification</h2><pre>Select and modify based on index/column names with () or the loc method:
 * df(indexNames,columnsNames)
 * df.loc(indexNames,columnsNames)
 * df(indexNames,columnsNames) = newData
 * df.loc(indexNames,columnsNames) = newData</pre><pre class="codeinput">df(1,:)
<span class="comment">% same as</span>
df.loc(1,:);
df(1);
df.loc(1);
</pre><pre class="codeoutput">
ans = 

         a     b
         __    _

    1    10    2

</pre><pre class="codeinput">df(1,:) = 10
<span class="comment">% Or df.loc(1,:) = 10</span>
</pre><pre class="codeoutput">
df = 

         a     b 
         __    __

    1    10    10
    2     3     4

</pre><p>One can also drop a column/row with the empty assignment</p><pre class="codeinput">tmp = df;
tmp(:,<span class="string">"b"</span>) = []
</pre><pre class="codeoutput">
tmp = 

         a 
         __

    1    10
    2     3

</pre><pre>Select and modify based on position with {} or the iloc method:
 *  df{indexPosition,columnsPosition}
 *  df.iloc(indexPosition,columnsPosition)
 *  df{indexPosition,columnsPosition} = newData
 *  df.iloc(indexPosition,columnsPosition) = newData</pre><pre class="codeinput">df{1:end,2}
<span class="comment">% same as</span>
df{:,2};
df.iloc(:,2);
</pre><pre class="codeoutput">
ans = 

         b 
         __

    1    10
    2     4

</pre><pre class="codeinput">df{2,1} = 20
<span class="comment">% or df.iloc(2,1) = 20</span>
df.data = [1 2;3 4];  <span class="comment">% reset data to original example</span>
</pre><pre class="codeoutput">
df = 

         a     b 
         __    __

    1    10    10
    2    20     4

</pre><h2 id="17">Operations</h2><p>Frames can be used like matrices for operations.</p><p>element-wise operation</p><pre class="codeinput">df + df
</pre><pre class="codeoutput">
ans = 

         a    b
         _    _

    1    2    4
    2    6    8

</pre><p>element-wise operation with a non-Frame</p><pre class="codeinput">1 + df
</pre><pre class="codeoutput">
ans = 

         a    b
         _    _

    1    2    3
    2    4    5

</pre><p>transpose and matrix operation</p><pre class="codeinput">df' * df
vector = frames.DataFrame([1;2],[<span class="string">"a"</span>,<span class="string">"b"</span>],<span class="string">"vectorColumn"</span>);
df * vector
</pre><pre class="codeoutput">
ans = 

         a     b 
         __    __

    a    10    14
    b    14    20


ans = 

         vectorColumn
         ____________

    1          5     
    2         11     

</pre><p>If Frames are not aligned, an element-wise operation will return an error:</p><pre class="codeinput">df2 = frames.DataFrame(1,[1 2],[<span class="string">"noMatch1"</span>,<span class="string">"noMatch2"</span>]);
<span class="keyword">try</span>
    df ./ df2
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Frames have different columns!
</pre><p>For element-wise vector operations, only one dimension is needed to be checked for right or wrong alignement.</p><p>To do so, one needs to set the <i>series property</i> of the vector Frame to true. There are two series properties available, <i>.rowseries</i>, and <i>.colseries</i>, depending on whether the Frame is a row or column vector.</p><p>If the property is not set, the operation fails:</p><pre class="codeinput">seriesBad = frames.DataFrame([1;2],[1 2],<span class="string">"seriesColumn"</span>);
<span class="keyword">try</span>
    df .* seriesBad
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Frames have different columns!
</pre><pre class="codeinput">series = seriesBad.asColSeries();
<span class="comment">% or series = frames.DataFrame([1;2],[1 2],"seriesColumn",ColSeries=true);</span>
details(series)
df .* series
</pre><pre class="codeoutput">
  2&times;1 frames.DataFrame array with properties:

           data: [2&times;1 double]
          index: [2&times;1 double]
        columns: "seriesColumn"
           name: ""
              t: [2&times;1 table]
      rowseries: 0
      colseries: 1
    description: ""



ans = 

         a    b
         _    _

    1    1    2
    2    6    8

</pre><h2 id="24">Concatenation</h2><p>One can concatenate different Frames into one with the operator [].</p><p>The concatenation can be horizontal or vertical. The operation will align the Frames by expanding (unifying) their index or columns if they are not equal, inserting missing values in the expansion.</p><pre class="codeinput">tf1 = frames.TimeFrame(1,frames.TimeIndex([<span class="string">"25.06.2021"</span>,<span class="string">"27.06.2021"</span>,<span class="string">"28.06.2021"</span>]),[<span class="string">"ts1"</span>,<span class="string">"ts2"</span>]);
tf2 = frames.TimeFrame(2,frames.TimeIndex([<span class="string">"26.06.2021"</span>,<span class="string">"27.06.2021"</span>,<span class="string">"30.06.2021"</span>]),<span class="string">"ts3"</span>);
[tf1, tf2]
</pre><pre class="codeoutput">
ans = 

       Time        ts1    ts2    ts3
    ___________    ___    ___    ___

    25-Jun-2021      1      1    NaN
    26-Jun-2021    NaN    NaN      2
    27-Jun-2021      1      1      2
    28-Jun-2021      1      1    NaN
    30-Jun-2021    NaN    NaN      2

</pre><pre class="codeinput">tf3 = frames.TimeFrame(2,frames.TimeIndex([<span class="string">"29.06.2021"</span>,<span class="string">"30.06.2021"</span>]),[<span class="string">"ts2"</span>,<span class="string">"ts3"</span>]);
[tf1; tf3]
</pre><pre class="codeoutput">
ans = 

       Time        ts1    ts2    ts3
    ___________    ___    ___    ___

    25-Jun-2021      1     1     NaN
    27-Jun-2021      1     1     NaN
    28-Jun-2021      1     1     NaN
    29-Jun-2021    NaN     2       2
    30-Jun-2021    NaN     2       2

</pre><h2 id="26">Particular use of Index</h2><p>The type of <i>index</i> can be specified, as one may have noticed in the example above.</p><p>By default, in DataFrame, the object underlying the index is a <i>frames.UniqueIndex</i>, and in TimeFrame, it is a <i>frames.TimeIndex</i>. The former requires unique elements, while the latter requires chronological unique time elements.</p><p>TimeFrame only accepts a TimeIndex, while DataFrame accepts UniqueIndex, TimeIndex, and SortedIndex (unique and sorted).</p><p>The distinction between the different Index impacts the operations of selection, modification, and alignment/concatenation.</p><pre class="codeinput">df.getIndex_()  <span class="comment">% gets the underlying Index object</span>
df([2 1])
</pre><pre class="codeoutput">
ans = 

  UniqueIndex with properties:

         name: "Row"
        value: [2&times;1 double]
    singleton: 0


ans = 

         a    b
         _    _

    2    3    4
    1    1    2

</pre><pre class="codeinput">dfSorted = df.setIndexType(<span class="string">"sorted"</span>);
dfSorted.getIndex_()
<span class="keyword">try</span>
    dfSorted([2 1])
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

  SortedIndex with properties:

         name: "Row"
        value: [2&times;1 double]
    singleton: 0

Index is not unique and sorted.
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% frames package
% The frames package contains classes to handle operations on homogeneous 
% data matrices that are referenced by column and index identifiers.
%
% There are currently no tool in Matlab to do that.
% Matlab's (time)tables have row and column names, but do not provide
% simple operations like addition (table1+table2 is not possible).
% Matlab's native matrices are not aware of row and column names. When data
% represents observations of variables, it is always tricky to make sure the
% data is not misaligned.
%
%% Frame classes
%
% The class *frames.DataFrame* and its child class *frames.TimeFrame* aim to 
% give a solution to working with this kind of data (homogeneous and with column and 
% row names), to make operations on and between Frames simple and robust.
%
% Their main properties are:
%
% * data:       TxN,  homogeneous data
% * index:      Tx1
% * columns:    1xN
% * t: dependent table built on the properties above.
%
% _columns_ and _index_ are expected to have unique elements. _columns_
% allows duplicates but issues a warning if it is the case. _index_ does
% not accept duplicates.
% Moreover, for TimeFrame, _index_ is a chronological datetime array.
%
% The Frames are displayed as a table (DataFrame) and as a timetable (TimeFrame).
%
% For the documentation, run
doc frames.DataFrame
doc frames.TimeFrame
%%
%% Constructor
% 
% Construct a Frame as follows:
%
%   df = frames.DataFrame([data,index,columns,Name=name,RowSeries=logical,ColSeries=logical])
df = frames.DataFrame([1 2;3 4],[1 2],["col1","col2"])
%%
% or with a TimeFrame
tf = frames.TimeFrame([1 2;3 4],[737970,737971],["ts1","ts2"])
%%
% To view the properties of the object, type
details(df)
%%
% One can see the properties we have just set in the constructor.
% The other properties (some of which can be set in the constructor with
% named arguments) are presented further below.
%
%% Properties Access and Modification
% The properties can be accessed simply by
df.data
df.columns
%%
% They can also be modified
df.data(1,1) = 10;
df.columns = ["a","b"]
%%
% Frame will throw an error if the data entered are not coherent, e.g. the
% size is the matching the rest of the data:
try
    df.columns = ["a","b","c"]
catch me
    disp(me.message)
end
%%
% Or an example with an attempt to assign a duplicate index:
try
    df.index = [1 1]
catch me
    disp(me.message)
end
%% Sub-Frame Access and Modification

%%
%  Select and modify based on index/column names with () or the loc method:
%   * df(indexNames,columnsNames)
%   * df.loc(indexNames,columnsNames)
%   * df(indexNames,columnsNames) = newData
%   * df.loc(indexNames,columnsNames) = newData
df(1,:)
% same as
df.loc(1,:);
df(1);
df.loc(1);
%%
df(1,:) = 10
% Or df.loc(1,:) = 10
%%
% One can also drop a column/row with the empty assignment
tmp = df;
tmp(:,"b") = []
%%
%  Select and modify based on position with {} or the iloc method:
%   *  df{indexPosition,columnsPosition}
%   *  df.iloc(indexPosition,columnsPosition)
%   *  df{indexPosition,columnsPosition} = newData
%   *  df.iloc(indexPosition,columnsPosition) = newData
df{1:end,2}
% same as
df{:,2};
df.iloc(:,2);
%%
df{2,1} = 20
% or df.iloc(2,1) = 20
df.data = [1 2;3 4];  % reset data to original example
%% Operations
% Frames can be used like matrices for operations.
%%
% element-wise operation
df + df
%%
% element-wise operation with a non-Frame 
1 + df
%%
% transpose and matrix operation
df' * df
vector = frames.DataFrame([1;2],["a","b"],"vectorColumn");
df * vector
%%
% If Frames are not aligned, an element-wise operation will return an error:
df2 = frames.DataFrame(1,[1 2],["noMatch1","noMatch2"]);
try
    df ./ df2
catch me
    disp(me.message)
end
%%
% For element-wise vector operations, only one dimension is needed to be checked for
% right or wrong alignement.
%
% To do so, one needs to set the _series property_ of the vector Frame to
% true. There are two series properties available, _.rowseries_, and
% _.colseries_, depending on whether the Frame is a row or column vector.
%
% If the property is not set, the operation fails:
seriesBad = frames.DataFrame([1;2],[1 2],"seriesColumn");
try
    df .* seriesBad
catch me 
    disp(me.message)
end
%%
series = seriesBad.asColSeries();
% or series = frames.DataFrame([1;2],[1 2],"seriesColumn",ColSeries=true);
details(series)
df .* series
%% Concatenation
% One can concatenate different Frames into one with the operator [].
%
% The concatenation can be horizontal or vertical. The operation will
% align the Frames by expanding (unifying) their index or columns if they 
% are not equal, inserting missing values in the expansion.
tf1 = frames.TimeFrame(1,frames.TimeIndex(["25.06.2021","27.06.2021","28.06.2021"]),["ts1","ts2"]);
tf2 = frames.TimeFrame(2,frames.TimeIndex(["26.06.2021","27.06.2021","30.06.2021"]),"ts3");
[tf1, tf2]
%%
tf3 = frames.TimeFrame(2,frames.TimeIndex(["29.06.2021","30.06.2021"]),["ts2","ts3"]);
[tf1; tf3]
%% Particular use of Index
% The type of _index_ can be specified, as one may have noticed in the
% example above.
%
% By default, in DataFrame, the object underlying the index is a
% _frames.UniqueIndex_, and in TimeFrame, it is a _frames.TimeIndex_.
% The former requires unique elements, while the latter requires chronological
% unique time elements.
%
% TimeFrame only accepts a TimeIndex, while DataFrame accepts UniqueIndex,
% TimeIndex, and SortedIndex (unique and sorted).
%
% The distinction between the different Index impacts the operations of
% selection, modification, and alignment/concatenation.
df.getIndex_()  % gets the underlying Index object
df([2 1])
%%
dfSorted = df.setIndexType("sorted");
dfSorted.getIndex_()
try
    dfSorted([2 1])
catch me
    disp(me.message)
end

##### SOURCE END #####
--></body></html>