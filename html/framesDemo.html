
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Frames package</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-08-23"><meta name="DC.source" content="framesDemo.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><b>Frames</b> package</h1><!--introduction--><p>The <b>frames</b> package contains a class to store and do operations on data matrices that are referenced by column and index identifiers.</p><p>Matlab currently provide matrices and tables, but they do not work well together:</p><p>- Matlab native matrices are not aware of row and column names; when data represents observations of variables, it is always tricky to make sure the data is not misaligned (i.e. how to make sure that the ith row in matrices A and B represents the same observation).</p><p>- Matlab (time)tables have row and column names, but do not provide simple operations like addition (table1+table2 is not possible).</p><p><b>Frames</b> aims at being both a table and a matrix, allowing matrix operations while being aware of row and column names.</p><p>The package currently requires a version of <b>Matlab R2021a</b> or later.</p><p>Author: Benjamin Gaudin</p><p>Email: <a href="mailto:frames.matlab@gmail.com">frames.matlab@gmail.com</a></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Frame classes</a></li><li><a href="#5">Constructor</a></li><li><a href="#10">Properties Access and Modification</a></li><li><a href="#14">Sub-Frame Access and Modification</a></li><li><a href="#21">Operations</a></li><li><a href="#29">Concatenation</a></li><li><a href="#31">Index Object</a></li><li><a href="#40">Methods Chaining</a></li><li><a href="#44">Rolling and Ewm</a></li><li><a href="#50">Split Apply</a></li><li><a href="#56">Other Methods</a></li></ul></div><h2 id="1">Frame classes</h2><p>The class <b>DataFrame</b> and its child class <b>TimeFrame</b> provide a data type suitable when working with <i>matrices</i> that have <i>column and row names.</i> They make operations on and between Frames simple and robust. The distinction between the two is similar to that between Matlab native <i>table</i> and <i>timetable</i>; basically, the properties and methods are the same, but there are a few additional tools to handle time series in TimeFrame.</p><p>The main properties of these classes are:</p><div><ul><li>data: TxN, data matrix</li><li>index: Tx1</li><li>columns: 1xN</li><li>t: dependent table built on the properties above.</li></ul></div><p>The Frames are displayed as a table (DataFrame) or as a timetable (TimeFrame).</p><p>For the documentation, run</p><pre class="codeinput">doc <span class="string">frames.DataFrame</span>
doc <span class="string">frames.TimeFrame</span>
</pre><h2 id="5">Constructor</h2><p>Construct a Frame as follows:</p><pre>df = frames.DataFrame([data,index,columns,Name=name,RowSeries=logical,ColSeries=logical])</pre><pre class="codeinput"><span class="comment">% Example:</span>
df = frames.DataFrame([1 2;3 4],[1 2],[<span class="string">"col1"</span>,<span class="string">"col2"</span>])
</pre><pre class="codeoutput">
df = 

         col1    col2
         ____    ____

    1     1       2  
    2     3       4  

</pre><p>or with a TimeFrame</p><pre class="codeinput">tf = frames.TimeFrame([1 2;3 4],[738336,738337],[<span class="string">"ts1"</span>,<span class="string">"ts2"</span>])
</pre><pre class="codeoutput">
tf = 

       Time        ts1    ts2
    ___________    ___    ___

    29-Jun-2021     1      2 
    30-Jun-2021     3      4 

</pre><p>To view the properties of the object, type</p><pre class="codeinput">details(df)
</pre><pre class="codeoutput">
  2&times;2 frames.DataFrame array with properties:

                    data: [2&times;2 double]
                   index: [2&times;1 double]
                 columns: ["col1"    "col2"]
                    name: ""
                       t: [2&times;2 table]
               rowseries: 0
               colseries: 0
    identifierProperties: [1&times;1 struct]
             description: ""


</pre><p>One can see the properties we have just set in the constructor. The other properties (some of which can be set in the constructor with named arguments) are presented further below.</p><h2 id="10">Properties Access and Modification</h2><p>The properties can be accessed simply by</p><pre class="codeinput">df.data
df.columns
</pre><pre class="codeoutput">
ans =

     1     2
     3     4


ans = 

  1&times;2 string array

    "col1"    "col2"

</pre><p>They can also be modified</p><pre class="codeinput">df.data(1,1) = 10;
df.columns = [<span class="string">"a"</span>,<span class="string">"b"</span>]
</pre><pre class="codeoutput">
df = 

         a     b
         __    _

    1    10    2
    2     3    4

</pre><p>Frame will throw an error if the data entered are not coherent, e.g. the size is the matching the rest of the data:</p><pre class="codeinput"><span class="keyword">try</span>
    df.columns = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">columns do not have the same size as data
</pre><p>Or an example with an attempt to assign a duplicate index:</p><pre class="codeinput"><span class="keyword">try</span>
    df.index = [1 1]
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Index value is required to be unique.
</pre><h2 id="14">Sub-Frame Access and Modification</h2><pre>Select and modify based on index/column names with () or the loc method:
 * df(indexNames,columnsNames)
 * df.loc(indexNames,columnsNames)
 * df(indexNames,columnsNames) = newData
 * df.loc(indexNames,columnsNames) = newData</pre><pre class="codeinput"><span class="comment">% Selection</span>
df(1,:)
<span class="comment">% same as</span>
df.loc(1,:);
df(1);
df.loc(1);
</pre><pre class="codeoutput">
ans = 

         a     b
         __    _

    1    10    2

</pre><p>Modification</p><pre class="codeinput">df(1,:) = 11
<span class="comment">% Or df.loc(1,:) = 11</span>
</pre><pre class="codeoutput">
df = 

         a     b 
         __    __

    1    11    11
    2     3     4

</pre><p>One can also drop a column/row with the empty assignment</p><pre class="codeinput">tmp = df;
tmp(:,<span class="string">"b"</span>) = []
</pre><pre class="codeoutput">
tmp = 

         a 
         __

    1    11
    2     3

</pre><pre>Select and modify based on position with {} or the iloc method:
 *  df{indexPosition,columnsPosition}
 *  df.iloc(indexPosition,columnsPosition)
 *  df{indexPosition,columnsPosition} = newData
 *  df.iloc(indexPosition,columnsPosition) = newData</pre><pre class="codeinput">df{1:end,2}
<span class="comment">% same as</span>
df{:,2};
df.iloc(:,2);
</pre><pre class="codeoutput">
ans = 

         b 
         __

    1    11
    2     4

</pre><pre class="codeinput">df{2,1} = 20
<span class="comment">% or df.iloc(2,1) = 20</span>
</pre><pre class="codeoutput">
df = 

         a     b 
         __    __

    1    11    11
    2    20     4

</pre><pre class="codeinput">df.data = [1 2;3 4];  <span class="comment">% reset data to original example</span>
</pre><h2 id="21">Operations</h2><p>Frames can be used like matrices for operations.</p><p>element-wise operation</p><pre class="codeinput">df + df
</pre><pre class="codeoutput">
ans = 

         a    b
         _    _

    1    2    4
    2    6    8

</pre><p>Contrast this with Matlab table:</p><pre class="codeinput">tb = table([1;3],[2;4],<span class="string">'VariableNames'</span>,{<span class="string">'a'</span>,<span class="string">'b'</span>},<span class="string">'RowNames'</span>,{<span class="string">'1'</span>,<span class="string">'2'</span>});
tb;
<span class="keyword">try</span>
    tb + tb
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Undefined function 'plus' for input arguments of type 'table'.
</pre><p>Element-wise operation with a non-Frame</p><pre class="codeinput"><span class="comment">% df + 1</span>
1 + df
</pre><pre class="codeoutput">
ans = 

         a    b
         _    _

    1    2    3
    2    4    5

</pre><p>transpose and matrix operation</p><pre class="codeinput">df' * df
</pre><pre class="codeoutput">
ans = 

         a     b 
         __    __

    a    10    14
    b    14    20

</pre><pre class="codeinput">vector = frames.DataFrame([1;2],[<span class="string">"a"</span>,<span class="string">"b"</span>],<span class="string">"vectorColumn"</span>);
df * vector
</pre><pre class="codeoutput">
ans = 

         vectorColumn
         ____________

    1          5     
    2         11     

</pre><p>If Frames are not aligned, an element-wise operation will return an error:</p><pre class="codeinput">df2 = frames.DataFrame(1,[1 2],[<span class="string">"noMatch1"</span>,<span class="string">"noMatch2"</span>]);
<span class="keyword">try</span>
    df ./ df2
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Frames have different columns!
</pre><p>For element-wise vector operations, only one dimension is needed to be checked for right or wrong alignement.</p><p>To do so, one needs to set the <i>series property</i> of the vector Frame to true. There are two series properties available, <i>.rowseries</i>, and <i>.colseries</i>, depending on whether the Frame is a row or column vector.</p><p>If the property is not set, the operation fails:</p><pre class="codeinput">seriesBad = frames.DataFrame([1;2],[1 2],<span class="string">"seriesColumn"</span>);
<span class="keyword">try</span>
    df .* seriesBad
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Frames have different columns!
</pre><p>Make it work by making the Frame a Series</p><pre class="codeinput">series = seriesBad.asColSeries();
<span class="comment">% or series = frames.DataFrame([1;2],[1 2],"seriesColumn",ColSeries=true);</span>
df .* series
</pre><pre class="codeoutput">
ans = 

         a    b
         _    _

    1    1    2
    2    6    8

</pre><h2 id="29">Concatenation</h2><p>One can concatenate different Frames into one with the operator [].</p><p>The concatenation can be horizontal or vertical. The operation will align the Frames by expanding (unifying) their index or columns if they are not equal, inserting missing values in the expansion.</p><pre class="codeinput">tf1 = frames.TimeFrame(1,[<span class="string">"25-Jun-2021"</span>,<span class="string">"27-Jun-2021"</span>,<span class="string">"28-Jun-2021"</span>],[<span class="string">"ts1"</span>,<span class="string">"ts2"</span>]);
tf2 = frames.TimeFrame(2,[<span class="string">"26-Jun-2021"</span>,<span class="string">"27-Jun-2021"</span>,<span class="string">"30-Jun-2021"</span>],<span class="string">"ts3"</span>);
[tf1, tf2]
</pre><pre class="codeoutput">
ans = 

       Time        ts1    ts2    ts3
    ___________    ___    ___    ___

    25-Jun-2021      1      1    NaN
    26-Jun-2021    NaN    NaN      2
    27-Jun-2021      1      1      2
    28-Jun-2021      1      1    NaN
    30-Jun-2021    NaN    NaN      2

</pre><pre class="codeinput">tf3 = frames.TimeFrame(2,frames.TimeIndex([<span class="string">"29.06.2021"</span>,<span class="string">"30.06.2021"</span>],Format=<span class="string">"dd.MM.yyyy"</span>),[<span class="string">"ts2"</span>,<span class="string">"ts3"</span>]);
[tf1; tf3]
</pre><pre class="codeoutput">
ans = 

       Time        ts1    ts2    ts3
    ___________    ___    ___    ___

    25-Jun-2021      1     1     NaN
    27-Jun-2021      1     1     NaN
    28-Jun-2021      1     1     NaN
    29-Jun-2021    NaN     2       2
    30-Jun-2021    NaN     2       2

</pre><h2 id="31">Index Object</h2><p>The <i>index</i> and <i>columns</i> properties can be assigned some properties themselves, namely whether they are required to have unique elements, and whether these are required to be sorted.</p><p>By default, the <i>columns</i> allow duplicates, while the <i>index</i> require unique elements. For TimeFrame, the <i>index</i> also requires sorted elements.</p><p>These can be changed by explicitely using the <i>Index</i> object that underlies the <i>index</i> and <i>columns</i> properties.</p><p>Here is an example of an Index:</p><pre>frames.Index(value,Unique=false,UniqueSorted=false,Singleton=false,Name="")</pre><pre class="codeinput">frames.Index([1,2])
</pre><pre class="codeoutput">
ans = 

  Index with properties:

                   name: ""
                  value: [2&times;1 double]
              singleton: 0
          requireUnique: 0
    requireUniqueSorted: 0

</pre><div><ul><li>The <i>singleton</i> property is related to the series property of the DataFrame. If the Frame is set to be a <i>rowseries</i>, the Index object underlying the <i>index</i> will be a <i>singleton</i>. If the Frame is set to be a <i>colseries</i>, then it will be that underlying the <i>columns</i>.</li><li>If <i>requireUnique</i> is set to <i>true</i>, then <i>value</i> is required to have unique elements (otherwise it throws an error).</li><li>If <i>requireUniqueSorted</i> is set to <i>true</i>, then <i>value</i> is required to have unique and sorted elements.</li></ul></div><p>These properties impact the operations of selection, modification, and alignment/concatenation.</p><pre class="codeinput"><span class="comment">% Selection</span>
df.getIndex_()  <span class="comment">% gets the underlying Index object</span>
df([2 1])
</pre><pre class="codeoutput">
ans = 

  Index with properties:

                   name: "Row"
                  value: [2&times;1 double]
              singleton: 0
          requireUnique: 1
    requireUniqueSorted: 0


ans = 

         a    b
         _    _

    2    3    4
    1    1    2

</pre><pre class="codeinput">dfSorted = df.setIndexType(<span class="string">"sorted"</span>);
<span class="comment">% or df.index = frames.Index([1 2],UniqueSorted=true)</span>
dfSorted.getIndex_()
<span class="keyword">try</span>
    dfSorted([2 1])
<span class="keyword">catch</span> me
    disp(me.message)
<span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

  Index with properties:

                   name: "Row"
                  value: [2&times;1 double]
              singleton: 0
          requireUnique: 1
    requireUniqueSorted: 1

Index value is required to be sorted and unique.
</pre><p>Alignment</p><pre class="codeinput">df1 = frames.DataFrame([1 3]',[1 3],1);
df2 = frames.DataFrame([2 3]',[2 3],2);
unsortedConcatenation = [df1,df2]
df1 = frames.DataFrame([1 3]',frames.Index([1 3],UniqueSorted=true),1);
df2 = frames.DataFrame([2 3]',frames.Index([2 3],UniqueSorted=true),2);
sortedConcatenation = [df1,df2]
</pre><pre class="codeoutput">
unsortedConcatenation = 

         x1     x2 
         ___    ___

    1      1    NaN
    3      3      3
    2    NaN      2


sortedConcatenation = 

         x1     x2 
         ___    ___

    1      1    NaN
    2    NaN      2
    3      3      3

</pre><p>For TimeFrame, the Index object for <i>index</i> is a <b>TimeIndex</b>.</p><p>TimeIndex can read several kinds of arguments: datenum, datetime, and strings/cell together with a Format</p><pre>frames.TimeIndex(value,Unique=false,UniqueSorted=false,Singleton=false,Name="Time",Format="dd-MMM-yyyy")</pre><pre class="codeinput">frames.TimeIndex(738336)
frames.TimeIndex(datetime(738336,<span class="string">'ConvertFrom'</span>,<span class="string">'datenum'</span>,Format=<span class="string">'dd-MMM-yyyy'</span>));
frames.TimeIndex(<span class="string">"29-Jun-2021"</span>,Format=<span class="string">"dd-MMM-yyyy"</span>);
</pre><pre class="codeoutput">
ans = 

  TimeIndex with properties:

                 format: "dd-MMM-yyyy"
                   name: "Time"
                  value: 29-Jun-2021
              singleton: 0
          requireUnique: 1
    requireUniqueSorted: 1

</pre><p>When used in a Frame (used by default in a TimeFrame), one can select a sub-Frame using a <i>timerange</i></p><pre class="codeinput">tf = frames.TimeFrame((1:6)',738331:738336)  <span class="comment">% the constructor turns 738331:738336 into a TimeIndex</span>
tf(timerange(-inf,datetime(738333,<span class="string">'ConvertFrom'</span>,<span class="string">'datenum'</span>),<span class="string">'closed'</span>));
<span class="comment">% This can also be easily written using a string as follows</span>
<span class="comment">% tf("dateStart:dateEnd:dateFormat")</span>
tf(<span class="string">"-inf:26*06*2021:dd*MM*yyyy"</span>)
<span class="comment">% or with curly brackets</span>
<span class="comment">% tf({dateStart,dateEnd})</span>
tf({-inf,<span class="string">"26-Jun-2021"</span>});
</pre><pre class="codeoutput">
tf = 

       Time        Var1
    ___________    ____

    24-Jun-2021     1  
    25-Jun-2021     2  
    26-Jun-2021     3  
    27-Jun-2021     4  
    28-Jun-2021     5  
    29-Jun-2021     6  


ans = 

       Time        Var1
    ___________    ____

    24-Jun-2021     1  
    25-Jun-2021     2  
    26-Jun-2021     3  

</pre><h2 id="40">Methods Chaining</h2><p>Several methods are available. Again, please refer to the documentation for the full list</p><pre class="codeinput">doc <span class="string">frames.DataFrame</span>
doc <span class="string">frames.TimeFrame</span>
</pre><p>Methods can be chained to apply them one after the other.</p><pre class="codeinput"><span class="comment">% Example: build random correlated data and apply functions to the TimeFrame.</span>
s = rng(2021);
nObs = 1000;
nVar = 3;
[randomRotationMatrix,~] = qr(randn(nVar));
randomEigenValues = rand(1,nVar);
covariance = randomRotationMatrix * diag(randomEigenValues) * randomRotationMatrix';
correlation = diag(diag(covariance).^-0.5) * covariance * diag(diag(covariance).^-0.5)
upper = chol(correlation);
randomData = randn(nObs,nVar)./100 + 1./3000;
correlatedData = randomData*upper;
tf = frames.TimeFrame(correlatedData,738336-nObs+1:738336,1:nVar);
</pre><pre class="codeoutput">
correlation =

    1.0000    0.4277   -0.5917
    0.4277    1.0000   -0.7770
   -0.5917   -0.7770    1.0000

</pre><pre class="codeinput">tf.cumsum().plot()  <span class="comment">% apply a cumulative sum and then plot the result</span>
</pre><img vspace="5" hspace="5" src="framesDemo_01.png" alt=""> <pre class="codeinput">tf.corr().heatmap(CellLabelFormat=<span class="string">'%.2f'</span>)  <span class="comment">% compute the correlation matrix and plot it as a heatmap</span>
</pre><img vspace="5" hspace="5" src="framesDemo_02.png" alt=""> <h2 id="44">Rolling and Ewm</h2><p>Computation on a rolling basis are available with the <i>.rolling()</i> and the <i>.ewm()</i> methods. <i>.rolling()</i> applies computations on a rolling window basis. <i>.ewm()</i> applies computations by weighting observations with exponentially decaying weights.</p><pre>Use:
 * .rolling(window[,windowNaN]).&lt;method&gt;
 * .ewm(&lt;DecayType&gt;=value).&lt;method&gt;</pre><p>Please refer to the documentation for details on arguments and methods.</p><pre class="codeinput">doc <span class="string">frames.DataFrame.rolling</span>
<span class="comment">% or</span>
doc <span class="string">frames.internal.Rolling</span>
</pre><pre class="codeinput">doc <span class="string">frames.DataFrame.ewm</span>
<span class="comment">% or</span>
doc <span class="string">frames.internal.ExponentiallyWeightedMoving</span>
</pre><p>Below, we give a few examples on how these methods can be used, using our previous TimeFrame.</p><pre class="codeinput">price = tf.compoundChange(<span class="string">'log'</span>);  <span class="comment">% assume tf contains log returns and compound them</span>
rollingMean = price.rolling(30).mean();  <span class="comment">% 30-day moving average</span>
exponentialMean = price.ewm(Span=30).mean();  <span class="comment">% 30-day exponentially moving average</span>
priceSmoothers = [price{:,1}, rollingMean{:,1}, exponentialMean{:,1}];  <span class="comment">% group the first series</span>
priceSmoothers.columns = [<span class="string">"original"</span>, <span class="string">"rolling"</span>, <span class="string">"smooth"</span>];  <span class="comment">% assign new column names</span>
priceSmoothers.name = <span class="string">"smoothers"</span>;  <span class="comment">% assign the name (it appears as the plot title)</span>
priceSmoothers.plot(Log=true)
</pre><pre class="codeoutput">Warning: Index value is not unique. 
</pre><img vspace="5" hspace="5" src="framesDemo_03.png" alt=""> <pre class="codeinput">tf.ewm(Halflife=10).std().plot(Title=<span class="string">'ewmstd'</span>)  <span class="comment">% exponentially weighted moving standard deviation</span>
</pre><img vspace="5" hspace="5" src="framesDemo_04.png" alt=""> <h2 id="50">Split Apply</h2><p>One can apply a function to groups of columns in a Frame using the method <i>.split(groups).apply(@&lt;function&gt;)</i>.</p><pre>The groups of columns can be expressed in different ways.
 * (cellArrayOfGroupLists,groupNames)
 * structure: fields are group names and values are elements in each group
 * frames.Group: Group whose property  are group names and property
     values are elements in each group. See 'doc frames.Group' for more
     details.</pre><pre class="codeinput">df = frames.DataFrame([1 2 3;2 5 3;5 0 1]',[],[<span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span>])
</pre><pre class="codeoutput">
df = 

         a    b    c
         _    _    _

    1    1    2    5
    2    2    5    0
    3    3    3    1

</pre><pre class="codeinput"><span class="comment">% simple example with cell</span>
<span class="comment">% apply a sum horizontally in each group</span>
x1 = df.split({[<span class="string">"a"</span> <span class="string">"c"</span>],<span class="string">"b"</span>},[<span class="string">"group1"</span>,<span class="string">"group2"</span>]).apply(@(x) x.sum(2))
</pre><pre class="codeoutput">
x1 = 

         group1    group2
         ______    ______

    1      6         2   
    2      2         5   
    3      4         3   

</pre><pre class="codeinput"><span class="comment">% apply function using group names</span>
<span class="comment">% multiply each group by 10 and 1 respectively</span>
multiplier.group1 = 10;
multiplier.group2 = 1;
x2 = df.split({[<span class="string">"a"</span> <span class="string">"c"</span>],<span class="string">"b"</span>},[<span class="string">"group1"</span>,<span class="string">"group2"</span>]).apply(@(x) x.*multiplier.(x.name))
</pre><pre class="codeoutput">
x2 = 

         a     c     b
         __    __    _

    1    10    50    2
    2    20     0    5
    3    30    10    3

</pre><pre class="codeinput"><span class="comment">% split with a structure</span>
<span class="comment">% cap each group at 1.5 and 2.5 respectively</span>
s = struct();
s.group1 = [<span class="string">"a"</span> <span class="string">"c"</span>];
s.group2 = <span class="string">"b"</span>;
ceiler.group1 = 1.5;
ceiler.group2 = 2.5;
x3 = df.split(s).apply(@(x) x.clip(ceiler.(x.name)))
</pre><pre class="codeoutput">
x3 = 

          a      c      b 
         ___    ___    ___

    1      1    1.5      2
    2    1.5      0    2.5
    3    1.5      1    2.5

</pre><pre class="codeinput"><span class="comment">% split with a Group</span>
<span class="comment">% take the maximum of each groups at each row</span>
g = frames.Groups(df.columns,s);
x4 = df.split(g).apply(@(x) x.max(2))
</pre><pre class="codeoutput">
x4 = 

         group1    group2
         ______    ______

    1      5         2   
    2      2         5   
    3      3         3   

</pre><h2 id="56">Other Methods</h2><p>We list here all the methods available in the DataFrame. We provided a demo above for some of them.</p><p>Refer to the documentation for detailed information. You can also refer to the unit tests (+frames/+unitTests/) for some examples.</p><pre class="codeinput">methods(<span class="string">'frames.DataFrame'</span>)
</pre><pre class="codeoutput">
Methods for class frames.DataFrame:

DataFrame         extendIndex       loc               shift             
abs               ffill             log               sign              
all               findgroups        max               size              
any               firstCommonIndex  maxOf             sortBy            
asColSeries       firstValidIndex   mean              sortIndex         
asRowSeries       floor             median            split             
bfill             getColumns_       min               splitapply        
ceil              getIndex_         minOf             sqrt              
clip              groupcounts       nansum            std               
compoundChange    groupfilter       outerjoin         subsasgn          
corr              groupsummary      plot              subsref           
cov               grouptransform    relChg            sum               
cumprod           head              replace           tail              
cumsum            heatmap           replaceStartBy    tanh              
diff              height            resample          toFile            
dropColumns       horzcat           rolling           union             
dropIndex         iloc              setColumnsName    var               
dropMissing       innerjoin         setColumnsType    vertcat           
emptyStart        intersect         setIndex          width             
equals            isempty           setIndexName      
ewm               ismember          setIndexType      
exp               ismissing         setdiff           
extendColumns     join              setxor            

Static methods:

empty             fromFile          fromTable         

</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% *Frames* package
% The *frames* package contains a class to store and do operations on data matrices 
% that are referenced by column and index identifiers.
% 
% Matlab currently provide matrices and tables, but they do not work well together:
% 
% - Matlab native matrices are not aware of row and column names; when data 
% represents observations of variables, it is always tricky to make sure the data 
% is not misaligned (i.e. how to make sure that the ith row in matrices A and 
% B represents the same observation).
% 
% - Matlab (time)tables have row and column names, but do not provide simple 
% operations like addition (table1+table2 is not possible). 
% 
% *Frames* aims at being both a table and a matrix, allowing matrix operations 
% while being aware of row and column names.
% 
% The package currently requires a version of *Matlab R2021a* or later.
% 
% Author: Benjamin Gaudin
% 
% Email: frames.matlab@gmail.com
%% Frame classes
% The class *DataFrame* and its child class *TimeFrame* provide a data type 
% suitable when working with _matrices_ that have _column and row names._ They 
% make operations on and between Frames simple and robust. The distinction between 
% the two is similar to that between Matlab native _table_ and _timetable_; basically, 
% the properties and methods are the same, but there are a few additional tools 
% to handle time series in TimeFrame.
% 
% The main properties of these classes are:
%% 
% * data: TxN, data matrix
% * index: Tx1
% * columns: 1xN
% * t: dependent table built on the properties above.
%% 
% The Frames are displayed as a table (DataFrame) or as a timetable (TimeFrame).
% 
% For the documentation, run

doc frames.DataFrame
doc frames.TimeFrame
%% 
% 
%% Constructor
% Construct a Frame as follows:
%%
% 
%  df = frames.DataFrame([data,index,columns,Name=name,RowSeries=logical,ColSeries=logical])
%

% Example:
df = frames.DataFrame([1 2;3 4],[1 2],["col1","col2"])
%% 
% or with a TimeFrame

tf = frames.TimeFrame([1 2;3 4],[738336,738337],["ts1","ts2"])
%% 
% To view the properties of the object, type

details(df)
%% 
% One can see the properties we have just set in the constructor. The other 
% properties (some of which can be set in the constructor with named arguments) 
% are presented further below.
%% Properties Access and Modification
% The properties can be accessed simply by

df.data
df.columns
%% 
% They can also be modified

df.data(1,1) = 10;
df.columns = ["a","b"]
%% 
% Frame will throw an error if the data entered are not coherent, e.g. the size 
% is the matching the rest of the data:

try
    df.columns = ["a","b","c"]
catch me
    disp(me.message)
end
%% 
% Or an example with an attempt to assign a duplicate index:

try
    df.index = [1 1]
catch me
    disp(me.message)
end
%% Sub-Frame Access and Modification
%%
% 
%  Select and modify based on index/column names with () or the loc method:
%   * df(indexNames,columnsNames)
%   * df.loc(indexNames,columnsNames)
%   * df(indexNames,columnsNames) = newData
%   * df.loc(indexNames,columnsNames) = newData
%

% Selection
df(1,:)
% same as
df.loc(1,:);
df(1);
df.loc(1);
%% 
% Modification

df(1,:) = 11
% Or df.loc(1,:) = 11
%% 
% One can also drop a column/row with the empty assignment

tmp = df;
tmp(:,"b") = []
%%
% 
%  Select and modify based on position with {} or the iloc method:
%   *  df{indexPosition,columnsPosition}
%   *  df.iloc(indexPosition,columnsPosition)
%   *  df{indexPosition,columnsPosition} = newData
%   *  df.iloc(indexPosition,columnsPosition) = newData
%

df{1:end,2}
% same as
df{:,2};
df.iloc(:,2);
%%
df{2,1} = 20
% or df.iloc(2,1) = 20
%%
df.data = [1 2;3 4];  % reset data to original example
%% Operations
% Frames can be used like matrices for operations.
% 
% element-wise operation

df + df
%% 
% Contrast this with Matlab table:

tb = table([1;3],[2;4],'VariableNames',{'a','b'},'RowNames',{'1','2'});
tb;
try
    tb + tb
catch me
    disp(me.message)
end
%% 
% Element-wise operation with a non-Frame 

% df + 1
1 + df
%% 
% transpose and matrix operation

df' * df
%%
vector = frames.DataFrame([1;2],["a","b"],"vectorColumn");
df * vector
%% 
% If Frames are not aligned, an element-wise operation will return an error:

df2 = frames.DataFrame(1,[1 2],["noMatch1","noMatch2"]);
try
    df ./ df2
catch me
    disp(me.message)
end
%% 
% For element-wise vector operations, only one dimension is needed to be checked 
% for right or wrong alignement.
% 
% To do so, one needs to set the _series property_ of the vector Frame to true. 
% There are two series properties available, _.rowseries_, and _.colseries_, depending 
% on whether the Frame is a row or column vector.
% 
% If the property is not set, the operation fails:

seriesBad = frames.DataFrame([1;2],[1 2],"seriesColumn");
try
    df .* seriesBad
catch me 
    disp(me.message)
end
%% 
% Make it work by making the Frame a Series

series = seriesBad.asColSeries();
% or series = frames.DataFrame([1;2],[1 2],"seriesColumn",ColSeries=true);
df .* series
%% Concatenation
% One can concatenate different Frames into one with the operator [].
% 
% The concatenation can be horizontal or vertical. The operation will align 
% the Frames by expanding (unifying) their index or columns if they are not equal, 
% inserting missing values in the expansion.

tf1 = frames.TimeFrame(1,["25-Jun-2021","27-Jun-2021","28-Jun-2021"],["ts1","ts2"]);
tf2 = frames.TimeFrame(2,["26-Jun-2021","27-Jun-2021","30-Jun-2021"],"ts3");
[tf1, tf2]
%%
tf3 = frames.TimeFrame(2,frames.TimeIndex(["29.06.2021","30.06.2021"],Format="dd.MM.yyyy"),["ts2","ts3"]);
[tf1; tf3]
%% Index Object
% The _index_ and _columns_ properties can be assigned some properties themselves, 
% namely whether they are required to have unique elements, and whether these 
% are required to be sorted.
% 
% By default, the _columns_ allow duplicates, while the _index_ require unique 
% elements. For TimeFrame, the _index_ also requires sorted elements.
% 
% These can be changed by explicitely using the _Index_ object that underlies 
% the _index_ and _columns_ properties.
% 
% Here is an example of an Index:
%%
% 
%  frames.Index(value,Unique=false,UniqueSorted=false,Singleton=false,Name="")
%

frames.Index([1,2])
%% 
% * The _singleton_ property is related to the series property of the DataFrame. 
% If the Frame is set to be a _rowseries_, the Index object underlying the _index_ 
% will be a _singleton_. If the Frame is set to be a _colseries_, then it will 
% be that underlying the _columns_.
% * If _requireUnique_ is set to _true_, then _value_ is required to have unique 
% elements (otherwise it throws an error).
% * If _requireUniqueSorted_ is set to _true_, then _value_ is required to have 
% unique and sorted elements.
%% 
% These properties impact the operations of selection, modification, and alignment/concatenation.

% Selection
df.getIndex_()  % gets the underlying Index object
df([2 1])
%%
dfSorted = df.setIndexType("sorted");
% or df.index = frames.Index([1 2],UniqueSorted=true)
dfSorted.getIndex_()
try
    dfSorted([2 1])
catch me
    disp(me.message)
end
%% 
% Alignment

df1 = frames.DataFrame([1 3]',[1 3],1);
df2 = frames.DataFrame([2 3]',[2 3],2);
unsortedConcatenation = [df1,df2]
df1 = frames.DataFrame([1 3]',frames.Index([1 3],UniqueSorted=true),1);
df2 = frames.DataFrame([2 3]',frames.Index([2 3],UniqueSorted=true),2);
sortedConcatenation = [df1,df2]
%% 
% For TimeFrame, the Index object for _index_ is a *TimeIndex*.
% 
% TimeIndex can read several kinds of arguments: datenum, datetime, and strings/cell 
% together with a Format
%%
% 
%  frames.TimeIndex(value,Unique=false,UniqueSorted=false,Singleton=false,Name="Time",Format="dd-MMM-yyyy")
%

frames.TimeIndex(738336)
frames.TimeIndex(datetime(738336,'ConvertFrom','datenum',Format='dd-MMM-yyyy'));
frames.TimeIndex("29-Jun-2021",Format="dd-MMM-yyyy");
%% 
% When used in a Frame (used by default in a TimeFrame), one can select a sub-Frame 
% using a _timerange_

tf = frames.TimeFrame((1:6)',738331:738336)  % the constructor turns 738331:738336 into a TimeIndex
tf(timerange(-inf,datetime(738333,'ConvertFrom','datenum'),'closed'));
% This can also be easily written using a string as follows
% tf("dateStart:dateEnd:dateFormat")
tf("-inf:26*06*2021:dd*MM*yyyy")
% or with curly brackets
% tf({dateStart,dateEnd})
tf({-inf,"26-Jun-2021"});
%% Methods Chaining
% Several methods are available. Again, please refer to the documentation for 
% the full list

doc frames.DataFrame
doc frames.TimeFrame
%% 
% Methods can be chained to apply them one after the other.

% Example: build random correlated data and apply functions to the TimeFrame.
s = rng(2021);
nObs = 1000;
nVar = 3;
[randomRotationMatrix,~] = qr(randn(nVar));
randomEigenValues = rand(1,nVar);
covariance = randomRotationMatrix * diag(randomEigenValues) * randomRotationMatrix';
correlation = diag(diag(covariance).^-0.5) * covariance * diag(diag(covariance).^-0.5)
upper = chol(correlation);
randomData = randn(nObs,nVar)./100 + 1./3000;
correlatedData = randomData*upper;
tf = frames.TimeFrame(correlatedData,738336-nObs+1:738336,1:nVar);
%%
tf.cumsum().plot()  % apply a cumulative sum and then plot the result
%%
tf.corr().heatmap(CellLabelFormat='%.2f')  % compute the correlation matrix and plot it as a heatmap
%% Rolling and Ewm
% Computation on a rolling basis are available with the _.rolling()_ and the  
% _.ewm()_ methods. _.rolling()_ applies computations on a rolling window basis.  
% _.ewm()_ applies computations by weighting observations with exponentially decaying 
% weights.
%%
% 
%  Use:
%   * .rolling(window[,windowNaN]).<method>
%   * .ewm(<DecayType>=value).<method>
%
%% 
% Please refer to the documentation for details on arguments and methods.

doc frames.DataFrame.rolling
% or 
doc frames.internal.Rolling
%%
doc frames.DataFrame.ewm
% or
doc frames.internal.ExponentiallyWeightedMoving
%% 
% Below, we give a few examples on how these methods can be used, using our 
% previous TimeFrame.

price = tf.compoundChange('log');  % assume tf contains log returns and compound them
rollingMean = price.rolling(30).mean();  % 30-day moving average
exponentialMean = price.ewm(Span=30).mean();  % 30-day exponentially moving average
priceSmoothers = [price{:,1}, rollingMean{:,1}, exponentialMean{:,1}];  % group the first series
priceSmoothers.columns = ["original", "rolling", "smooth"];  % assign new column names
priceSmoothers.name = "smoothers";  % assign the name (it appears as the plot title)
priceSmoothers.plot(Log=true)
%%
tf.ewm(Halflife=10).std().plot(Title='ewmstd')  % exponentially weighted moving standard deviation
%% Split Apply
% One can apply a function to groups of columns in a Frame using the method  
% _.split(groups).apply(@<function>)_.
%%
% 
%  The groups of columns can be expressed in different ways.
%   * (cellArrayOfGroupLists,groupNames)
%   * structure: fields are group names and values are elements in each group
%   * frames.Group: Group whose property  are group names and property
%       values are elements in each group. See 'doc frames.Group' for more
%       details.
%

df = frames.DataFrame([1 2 3;2 5 3;5 0 1]',[],["a" "b" "c"])
%% 
% 

% simple example with cell
% apply a sum horizontally in each group
x1 = df.split({["a" "c"],"b"},["group1","group2"]).apply(@(x) x.sum(2))
%% 
% 

% apply function using group names 
% multiply each group by 10 and 1 respectively
multiplier.group1 = 10;
multiplier.group2 = 1;
x2 = df.split({["a" "c"],"b"},["group1","group2"]).apply(@(x) x.*multiplier.(x.name))
%% 
% 

% split with a structure
% cap each group at 1.5 and 2.5 respectively
s = struct();
s.group1 = ["a" "c"];
s.group2 = "b";
ceiler.group1 = 1.5;
ceiler.group2 = 2.5;
x3 = df.split(s).apply(@(x) x.clip(ceiler.(x.name)))
%% 
% 

% split with a Group 
% take the maximum of each groups at each row
g = frames.Groups(df.columns,s);
x4 = df.split(g).apply(@(x) x.max(2))
%% Other Methods
% We list here all the methods available in the DataFrame. We provided a demo 
% above for some of them. 
% 
% Refer to the documentation for detailed information. You can also refer to 
% the unit tests (+frames/+unitTests/) for some examples.

methods('frames.DataFrame')
##### SOURCE END #####
--></body></html>